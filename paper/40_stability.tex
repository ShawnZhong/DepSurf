\section{Stability of eBPF Programs}
\label{sec:stability}




The Linux kernel is a large and complex system, and it is constantly evolving.
The kernel source code is updated frequently, and the changes can affect the eBPF programs.

\subsection{Stable and Unstable Interfaces}
\label{sec:stable_interface}

\minisec{Stable Interfaces of eBPF}
The Linux kernel provides some guarantees about the stability of eBPF ABI (Application Binary Interface).
The eBPF ISA (Instruction Set Architecture) and the calling convention of eBPF programs are considered stable,
and the kernel developers are committed to maintaining backward compatibility~\cite{bpf-design, bpf-isa}.
In addition to the low-level infrastructure, the definition of helper functions, arguments to the eBPF programs,
and the recognized return values are also part of the stable interfaces~\cite{bpf-design}.
There are also attempts to standardize the format of the object file~\cite{bpf-elf} to enable the distribution of compiled eBPF programs.

\minisec{Unstable Interfaces of eBPF}
Despite all the efforts to maintain the stability of the eBPF ABI, the eBPF programs are still susceptible to changes in the kernel source code.
First, the hooks for eBPF programs are not part of the stable interfaces.
This is especially true for dynamic instrumentation using kprobe,
where the hooks are tens of thousands of kernel functions and are subject to frequent additions, removals, and changes.
Therefore a kprobe that exists in one version of the kernel may not be available in another version.

In addition to the hooks, the content of the context argument passed to the eBPF programs is also unstable.
For eBPF programs taking in \texttt{struct pt\_regs *} as the context argument (e.g., kprobe, uprobes, and LSM programs),
the content in the \texttt{struct pt\_regs *} are merely a snapshot of the CPU registers at the time of the event.
eBPF programs read the content of the registers as the arguments to the function,
but the function signature can change.
Therefore the eBPF programs that read the arguments of the function are also unstable.
If the kernel developers change the function signature, the eBPF programs can silently read the wrong arguments.


Finally, the eBPF programs that interact with the kernel data structures are also unstable.
The helper function, \texttt{bpf\_probe\_read\_kernel},
which allows eBPF programs to read arbitrary memory locations in the kernel,
is available for all types of eBPF programs.
It is often used to read a kernel data structure to a local buffer or struct in the eBPF program.
Since kernel data structures constantly evolve, the eBPF programs may fail to read the expected data or read the wrong data.



\minisec{Stability of Different Program Types}
Based on the three sources of instability above, we assess the stability of each type of eBPF program,
and the result is summarized in Table~\ref{tab:ebpf_program_types}.
Network programs are the most stable since they are attached to the well-defined hooks in the network stack,
and the context argument points to packet data, which is relatively stable.
Helper functions that read kernel memory are generally not used in network programs, although there is no restriction.

Trace programs attached to kprobes are the least stable, for all three sources of instability.
Programs attached to tracepoints are relatively more stable, since the tracepoints are better maintained to try to avoid breaking changes,
and the context argument is a well-defined event struct, but such programs may still read internal kernel data structures.
eBPF programs attached to LSM hooks are more stable than kprobes since they are better maintained and the number
of LSM hooks is relatively small.
% , but still less stable than tracepoints.

\subsection{False Assumption of Stability}
The instability of eBPF programs is not widely recognized.

\minisec{kprobe}
The BCC project contains about roughly a hundred tools that are built on top of eBPF,
\todo{number} most of which are using kprobes.
People using the BCC tools have a general expectation that the tools work across
different versions of the kernel, but this is not always the case as we will show in Section~\ref{sec:case_study}.
A StackOverflow answer describes the kprobes used in BCC as
``quite stable'' in practice~\cite{bpf-stability-so}, but under the hood,
it comes from the constant effort of the BCC developers
to maintain compatibility and carefully select the hooks that are less likely to change.

\minisec{Tracepoint}
Due to the unstable nature of kprobes, people have been attempting to use tracepoints as a solution since
changing a tracepoint requires a patch to be accepted by the kernel developers.
However, there are some pitfalls in this approach.
First, tracepoints are often mistakenly considered stable, even by the author of the BCC tools~\cite{tcp-tracepoint,bpf-book},
but they are also subject to changes, just like kprobes. As we will show in Section~\ref{sec:case_study}, the likelihood of changing
a tracepoint is higher than that of a kprobe\todo{confirm data}.
Second, tracepoints are a method for static instrumentation, and they are not always available for the events that people want to trace.
Adding a new tracepoint is a non-trivial task, and it requires changes to the kernel source code.
Plus, upstreaming the changes to the kernel source code can take a long time, and the changes may not be accepted.
One example is the \texttt{block\_io\_\{start|done\}} tracepoints. It starts with a seemingly innocent kernel commit
\href{https://github.com/torvalds/linux/commit/450b7879e34517c3ebc3a35a53806fe40e60fac2}{\texttt{450b787}} that reorganized code and
marks two kernel functions as \texttt{static inline}. The change makes two krpoes unavailable and breaks 3 BCC tools. The bug report on BCC
is filed~\cite{bcc-bio-bug} 10 months after the kernel commit. The delay is likely because it takes time for the users to
upgrade to the new kernel version and discover the issue.
In order to fix the issue, the BCC developers proposed to add two new tracepoints
to the kernel. Accepting the patch takes yet another 8 months after the bug report~\cite{block-tracepoints}.
It takes another 2 months to update the BCC tools to use the new tracepoints~\cite{bcc-bio-fix}.
Despite the year-long effort, the new tracepoints are only available for newer kernel versions, and the 3 tools are still broken
from Linux 5.17 to 6.4, spanning 15 months.

\minisec{LSM}
There are fewer tools built on top of LSM, but the stability issue is still present.
Some people believe that LSM is ``quite stable''~\cite{lsm-stability} because it is a part of the security infrastructure.
However, there is no such guarantee. Quoting from the author and maintainer of the eBPF LSM, KP Singh:
``we *do not* want to make LSM hooks a stable API and expect the eBPF programs to adapt when such changes occur''~\cite{bpf-lsm-stability}.
The fact that the LSM hooks are not part of the stable interfaces is not widely recognized, and it has implications for the security of the system.




\subsection{Consequence of the Instability}
Consider the LSM hook \texttt{inode\_setxattr}.
The hook is called before setting an extended attribute on a file to check if the operation is allowed.
A return value of 0 means the operation is allowed, and a negative value means the operation is denied.
The function prototype is as follows on Linux 5.11:

\begin{minted}{c}
int inode_setxattr(
  struct dentry *dentry, const char *name, 
  const void *value, size_t size, int flags);
\end{minted}

\noindent
An eBPF program can be attached to the LSM hook to control access to the extended attributes.
The return value of the program is used to determine if the operation is allowed.
The following is an example of an eBPF program that denies setting an extended attribute with the name \texttt{user.malicious}:


\begin{minted}{c}
SEC("lsm/inode_setxattr")
int prog(struct pt_regs *ctx) {
  char name[32];  // read the 2nd arg to `name`
  bpf_probe_read_str(name, 32, PT_REGS_PARM2(ctx));

  if (strncmp(name, "user.malicious", 14) == 0)
    return -EACCES;  // reject malicious xattr
  return 0;  // allow other xattrs
}
\end{minted}

\noindent
The program reads the second argument to \texttt{inode\_setxattr} and checks if it matches \texttt{user.malicious}.
If it does, the program returns \texttt{-EACCES} to deny the operation.
This program works well on Linux 5.11, but it does not work on Linux 5.15.
This is because the function signature of \texttt{inode\_setxattr} has changed to the following:

\begin{minted}{c}
int inode_setxattr(struct user_namespace *userns, 
  struct dentry *dentry, const char *name, 
  const void *value, size_t size, int flags);
\end{minted}

\noindent
There is one more argument at the beginning of the function signature, and the eBPF program reads the wrong arguments.
The program may silently allow the setting of the \texttt{user.malicious} attribute, which is a security risk.



% \minisec{CO-RE and BTF}
% \shawn{Let's see if we need to mention CO-RE and BTF here.
%   We can just talk about compatibility/stability in the context of the source code
%   (assuming that the eBPF programs are compiled with the same version of the kernel source code), as opposed to the binary compatibility.
% }
